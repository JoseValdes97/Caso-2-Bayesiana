vmu <- 1/(1/g20 + m/tau2)
mu  <- rnorm(n = 1, mean = vmu*(mu0/g20 + m*mean(theta)/tau2), sd = sqrt(vmu))
# actualizar tau^2
tau2 <- 1/rgamma(n = 1, shape = 0.5*(eta0 + m), rate = 0.5*(eta0*t20 + (m-1)*var(theta) + m*(mean(theta) - mu)^2))
# almacenar valores
THETA[b,] <- c(theta, sig2, mu, tau2)
# log-verosimilitud
LL[b] <- sum(dnorm(x = y, mean = rep(theta, nj), sd = sqrt(sig2), log = T))
}
# fin de la cadena
# salida
colnames(THETA) <- c(paste0("theta",1:m), "sig2", "mu", "tau2")
colnames(LL) <- c("ll")
THETA <- as.data.frame(THETA)
LL    <- as.data.frame(LL)
return(list(THETA = THETA, LL = LL))
}
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M2 <- MCMC_2(y,B = 11000, nj, yb, s2)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M2$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 2")
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M3 <- MCMC_3(y, B = 11000, nj, yb, s2)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M3$LL$ll)
# GrÃ¡fico
plot(cadena1_M3$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 3")
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M2$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll[-1:1000], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 2")
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M2$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll[-1:1000,], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 2")
adena1_M2$LL$ll
cadena1_M2$LL$ll
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M2$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll[-1000], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 2")
cadena1_M2$LL$ll[-1000]
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M2$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll[1001:], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 2")
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M2$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll[1001:length(cadena1_M2$LL$ll)], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 2")
# Primer modelo
MCMC_1 <- function(y, B) {
# tamaño y estadísticos
n      <- length(y)
sum_y  <- sum(y)
mean_y <- mean(y)
var_y  <- var(y)
# hiperparametros
mu0  <- 13.495
g20  <- 11.382
nu0  <- 1
s20  <- 1.182
# almacenamiento
THETA <- matrix(data = NA, nrow = B, ncol = 2)
LL    <- matrix(data = NA, nrow = B, ncol = 1)
# valores iniciales
#    valor inicial: simular de la previa
set.seed(2023)
theta <- rnorm(n = 1, mean = mu0, sd = sqrt(g20))
sig2  <- rgamma(n = 1, shape = nu0/2, rate = nu0*s20/2)
THETA[1,] <- c(theta,sig2)
# cadena
set.seed(2023)
for (b in 2:B) {
# 2.1 actualizar el valor de theta
g2n   <- 1/(1/g20 + n*sig2)
mun   <- (mu0/g20 + sum_y*sig2)*g2n
theta <- rnorm(n = 1, mean = mun, sd = sqrt(g2n))
THETA[b,] <- c(theta, sig2)
# 2.2 actualizar el valor de sigma^2
nun   <- nu0 + n
s2n   <- (nu0*s20 + (n-1)*var_y + n*(mean_y - theta)^2)/nun
sig2 <- rgamma(n = 1, shape = nun/2, rate = nun*s2n/2)
# 2.3 almacenar valores
THETA[b,] <- c(theta,sig2)
# log-verosimilitud
LL[b] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
}
# fin de la cadena
# salida
colnames(THETA) <- c("theta", "sig2")
colnames(LL) <- c("ll")
THETA <- as.data.frame(THETA)
LL    <- as.data.frame(LL)
return(list(THETA = THETA, LL = LL))
}
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M1 <- MCMC_1(y,B = 11000)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll[1001:length(cadena1_M2$LL$ll)], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M1 <- MCMC_1(y,B = 11000)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
yrange
cadena1_M1
# Primer modelo
MCMC_1 <- function(y, B) {
# tamaño y estadísticos
n      <- length(y)
sum_y  <- sum(y)
mean_y <- mean(y)
var_y  <- var(y)
# hiperparametros
mu0  <- 13.495
g20  <- 11.382
nu0  <- 1
s20  <- 1.182
# almacenamiento
THETA <- matrix(data = NA, nrow = B, ncol = 2)
LL    <- matrix(data = NA, nrow = B, ncol = 1)
# valores iniciales
#    valor inicial: simular de la previa
set.seed(2023)
theta <- rnorm(n = 1, mean = mu0, sd = sqrt(g20))
sig2  <- rgamma(n = 1, shape = nu0/2, rate = nu0*s20/2)
THETA[1,] <- c(theta,sig2)
LL[1] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
# cadena
set.seed(2023)
for (b in 2:B) {
# 2.1 actualizar el valor de theta
g2n   <- 1/(1/g20 + n*sig2)
mun   <- (mu0/g20 + sum_y*sig2)*g2n
theta <- rnorm(n = 1, mean = mun, sd = sqrt(g2n))
THETA[b,] <- c(theta, sig2)
# 2.2 actualizar el valor de sigma^2
nun   <- nu0 + n
s2n   <- (nu0*s20 + (n-1)*var_y + n*(mean_y - theta)^2)/nun
sig2 <- rgamma(n = 1, shape = nun/2, rate = nun*s2n/2)
# 2.3 almacenar valores
THETA[b,] <- c(theta,sig2)
# log-verosimilitud
LL[b] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
}
# fin de la cadena
# salida
colnames(THETA) <- c("theta", "sig2")
colnames(LL) <- c("ll")
THETA <- as.data.frame(THETA)
LL    <- as.data.frame(LL)
return(list(THETA = THETA, LL = LL))
}
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M1 <- MCMC_1(y,B = 11000)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
cadena1_M1
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll[-1], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll[-1])
# GrÃ¡fico
plot(cadena1_M1$LL$ll[-1], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
cadena1_M2
# Primer modelo
MCMC_1 <- function(y, B) {
# tamaño y estadísticos
n      <- length(y)
sum_y  <- sum(y)
mean_y <- mean(y)
var_y  <- var(y)
# hiperparametros
mu0  <- 13.495
g20  <- 11.382
nu0  <- 1
s20  <- 1.182
# almacenamiento
THETA <- matrix(data = NA, nrow = B, ncol = 2)
LL    <- matrix(data = NA, nrow = B, ncol = 1)
# valores iniciales
#    valor inicial: simular de la previa
set.seed(2023)
theta <- rnorm(n = 1, mean = mu0, sd = sqrt(g20))
sig2  <- rgamma(n = 1, shape = nu0/2, rate = nu0*s20/2)
THETA[1,] <- c(theta,sig2)
LL[1] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
# cadena
set.seed(2023)
for (b in 2:B) {
# 2.1 actualizar el valor de theta
g2n   <- 1/(1/g20 + n*sig2)
mun   <- (mu0/g20 + sum_y*sig2)*g2n
theta <- rnorm(n = 1, mean = mun, sd = sqrt(g2n))
# 2.2 actualizar el valor de sigma^2
nun   <- nu0 + n
s2n   <- (nu0*s20 + (n-1)*var_y + n*(mean_y - theta)^2)/nun
sig2 <- rgamma(n = 1, shape = nun/2, rate = nun*s2n/2)
# 2.3 almacenar valores
THETA[b,] <- c(theta,sig2)
# log-verosimilitud
LL[b] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
}
# fin de la cadena
# salida
colnames(THETA) <- c("theta", "sig2")
colnames(LL) <- c("ll")
THETA <- as.data.frame(THETA)
LL    <- as.data.frame(LL)
return(list(THETA = THETA, LL = LL))
}
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M1 <- MCMC_1(y,B = 11000)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll[-1])
# GrÃ¡fico
plot(cadena1_M1$LL$ll[-1], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
cadena1_M1
# Primer modelo
MCMC_1 <- function(y, B) {
# tamaño y estadísticos
n      <- length(y)
sum_y  <- sum(y)
mean_y <- mean(y)
var_y  <- var(y)
# hiperparametros
mu0  <- 13.495
g20  <- 11.382
nu0  <- 1
s20  <- 1.182
# almacenamiento
THETA <- matrix(data = NA, nrow = B, ncol = 2)
LL    <- matrix(data = NA, nrow = B, ncol = 1)
# valores iniciales
#    valor inicial: simular de la previa
set.seed(2023)
theta <- mean_y
sig2  <- var_y
THETA[1,] <- c(theta,sig2)
LL[1] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
# cadena
set.seed(2023)
for (b in 2:B) {
# 2.1 actualizar el valor de theta
g2n   <- 1/(1/g20 + n*sig2)
mun   <- (mu0/g20 + sum_y*sig2)*g2n
theta <- rnorm(n = 1, mean = mun, sd = sqrt(g2n))
# 2.2 actualizar el valor de sigma^2
nun   <- nu0 + n
s2n   <- (nu0*s20 + (n-1)*var_y + n*(mean_y - theta)^2)/nun
sig2 <- rgamma(n = 1, shape = nun/2, rate = nun*s2n/2)
# 2.3 almacenar valores
THETA[b,] <- c(theta,sig2)
# log-verosimilitud
LL[b] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
}
# fin de la cadena
# salida
colnames(THETA) <- c("theta", "sig2")
colnames(LL) <- c("ll")
THETA <- as.data.frame(THETA)
LL    <- as.data.frame(LL)
return(list(THETA = THETA, LL = LL))
}
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M1 <- MCMC_1(y,B = 11000)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
cadena1_M1
# Primer modelo
MCMC_1 <- function(y, B) {
# tamaño y estadísticos
n      <- length(y)
sum_y  <- sum(y)
mean_y <- mean(y)
var_y  <- var(y)
# hiperparametros
mu0  <- 13.495
g20  <- 11.382
nu0  <- 1
s20  <- 1.182
# almacenamiento
THETA <- matrix(data = NA, nrow = B, ncol = 2)
LL    <- matrix(data = NA, nrow = B, ncol = 1)
# valores iniciales
#    valor inicial: simular de la previa
set.seed(2023)
theta <- mean_y
sig2  <- var_y
# cadena
set.seed(2023)
for (b in 1:B) {
# 2.1 actualizar el valor de theta
g2n   <- 1/(1/g20 + n*sig2)
mun   <- (mu0/g20 + sum_y*sig2)*g2n
theta <- rnorm(n = 1, mean = mun, sd = sqrt(g2n))
# 2.2 actualizar el valor de sigma^2
nun   <- nu0 + n
s2n   <- (nu0*s20 + (n-1)*var_y + n*(mean_y - theta)^2)/nun
sig2 <- rgamma(n = 1, shape = nun/2, rate = nun*s2n/2)
# 2.3 almacenar valores
THETA[b,] <- c(theta,sig2)
# log-verosimilitud
LL[b] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
}
# fin de la cadena
# salida
colnames(THETA) <- c("theta", "sig2")
colnames(LL) <- c("ll")
THETA <- as.data.frame(THETA)
LL    <- as.data.frame(LL)
return(list(THETA = THETA, LL = LL))
}
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M1 <- MCMC_1(y,B = 11000)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
cadena1_M1
# Primer modelo
MCMC_1 <- function(y, B) {
# tamaño y estadísticos
n      <- length(y)
sum_y  <- sum(y)
mean_y <- mean(y)
var_y  <- var(y)
# hiperparametros
mu0  <- 13.495
g20  <- 11.382
nu0  <- 1
s20  <- 1.182
# almacenamiento
THETA <- matrix(data = NA, nrow = B, ncol = 2)
LL    <- matrix(data = NA, nrow = B, ncol = 1)
# valores iniciales
#    valor inicial: simular de la previa
set.seed(2023)
theta <- mean_y
sig2  <- var_y
# cadena
set.seed(2023)
for (b in 1:B) {
# 2.1 actualizar el valor de theta
g2n   <- 1/(1/g20 + n*sig2)
mun   <- (mu0/g20 + sum_y*sig2)*g2n
theta <- rnorm(n = 1, mean = mun, sd = sqrt(g2n))
# 2.2 actualizar el valor de sigma^2
nun   <- nu0 + n
s2n   <- (nu0*s20 + (n-1)*var_y + n*(mean_y - theta)^2)/nun
sig2 <- rgamma(n = 1, shape = nun/2, rate = nun*s2n/2)
# 2.3 almacenar valores
THETA[b,] <- c(theta,sig2)
# log-verosimilitud
LL[b] <- sum(dnorm(x = y, mean = rep(theta, n), sd = sqrt(sig2), log = T))
}
# fin de la cadena
# salida
colnames(THETA) <- c("theta", "sig2")
colnames(LL) <- c("ll")
THETA <- as.data.frame(THETA)
LL    <- as.data.frame(LL)
return(list(THETA = THETA, LL = LL))
}
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M1 <- MCMC_1(y,B = 11000)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M1$LL$ll)
# GrÃ¡fico
plot(cadena1_M1$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 1")
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M2 <- MCMC_2(y,B = 11000, nj, yb, s2)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M2$LL$ll)
# GrÃ¡fico
plot(cadena1_M2$LL$ll[1001:length(cadena1_M2$LL$ll)], type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 2")
#ajustar modelo
tictoc::tic()
set.seed(1856)
cadena1_M3 <- MCMC_3(y, B = 11000, nj, yb, s2)
tictoc::toc()
# cadenas
col <- RColorBrewer::brewer.pal(9,"Set1")[1:9]
yrange <- range(cadena1_M3$LL$ll)
# GrÃ¡fico
plot(cadena1_M3$LL$ll, type = "p", pch = ".", cex = 1.1, col = col[2], ylim = yrange, xlab = "Iteración", ylab = "Log-verosimilitud", main = "Modelo 3")
yb <- Estadisticos$yb
yb
nj
sum(nj)
# tabla con los estadisticos
Estadisticos <- Data %>%
group_by(Dominio) %>%
summarise(Dominio = unique(Dominio), nj = n(), yb = mean(Ingtot),
s2 = var(Ingtot))
head(Estadisticos)
# almacenar info importante
nj <- Estadisticos$nj
yb <- Estadisticos$yb
s2 <- Estadisticos$s2
length(y)
# m <- Cantidad de dominios (Departamentos)
m <- length(table(Data$Dominio))
m
# n <- nÃºmero de individuos
n <- sum(table(Data$Dominio))
n
# y <- vector con los datos
y <- Data$Ingtot
head(y)
# Sexto modelo
y_nj <- aggregate(Ingtot ~ Dominio, data = Data, sum)
y_nj
y_nj
# Sexto modelo
y_nj <- aggregate(log(Ingtot) ~ Dominio, data = Data, sum)
y_nj
# Sexto modelo
y_nj <- aggregate(Ingtot ~ Dominio, data = Data, sum)
y_nj
Ingtot
#datos que voy a usar
Data <- data.frame(dat$dominio, dat$ingtot)
#nombres
names(Data) <- c("Dominio","Ingtot")
# pasamos los Ingtot a escala logaritmica
Data[,2] <- log(Data$Ingtot)
# presentar datos
head(Data)
# comprobar media,varianza  y precisiÃ³n
mean(Data$Ingtot)
var(Data$Ingtot)
1/var(Data$Ingtot)
# volver factor domionio
class(Data$Dominio)
Data[,1] <- as.factor(Data$Dominio)
summary(Data$Dominio)
# Sexto modelo
y_nj <- aggregate(Data$Ingtot ~ Data$Dominio, data = Data, sum)
y_nj
# Sexto modelo
y_nj <- aggregate(y ~ Data$Dominio, data = Data, sum)
y_nj
